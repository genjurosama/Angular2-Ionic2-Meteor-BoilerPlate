{"version":3,"sources":["meteor://ðŸ’»app/packages/minifyStdCSS/plugin/minify-css.js"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/minifyStdCSS_plugin.js","sourcesContent":["var sourcemap = Npm.require('source-map');\n\nPlugin.registerMinifier({\n  extensions: [\"css\"]\n}, function () {\n  var minifier = new CssToolsMinifier();\n  return minifier;\n});\n\nfunction CssToolsMinifier () {};\n\nCssToolsMinifier.prototype.processFilesForBundle = function (files, options) {\n  var mode = options.minifyMode;\n\n  if (! files.length) return;\n\n  var merged = mergeCss(files);\n\n  if (mode === 'development') {\n    files[0].addStylesheet({\n      data: merged.code,\n      sourceMap: merged.sourceMap,\n      path: 'merged-stylesheets.css'\n    });\n    return;\n  }\n\n  var minifiedFiles = CssTools.minifyCss(merged.code);\n\n  if (files.length) {\n    minifiedFiles.forEach(function (minified) {\n      files[0].addStylesheet({\n        data: minified\n      });\n    });\n  }\n};\n\n// Lints CSS files and merges them into one file, fixing up source maps and\n// pulling any @import directives up to the top since the CSS spec does not\n// allow them to appear in the middle of a file.\nvar mergeCss = Profile(\"mergeCss\", function (css) {\n  // Filenames passed to AST manipulator mapped to their original files\n  var originals = {};\n\n  var cssAsts = css.map(function (file) {\n    var filename = file.getPathInBundle();\n    originals[filename] = file;\n    try {\n      var parseOptions = { source: filename, position: true };\n      var ast = CssTools.parseCss(file.getContentsAsString(), parseOptions);\n      ast.filename = filename;\n    } catch (e) {\n      if (e.reason) {\n        file.error({\n          message: e.reason,\n          line: e.line,\n          column: e.column\n        });\n      } else {\n        // Just in case it's not the normal error the library makes.\n        file.error({message: e.message});\n      }\n\n      return { type: \"stylesheet\", stylesheet: { rules: [] },\n        filename: filename };\n    }\n\n    return ast;\n  });\n\n  var warnCb = function (filename, msg) {\n    // XXX make this a buildmessage.warning call rather than a random log.\n    //     this API would be like buildmessage.error, but wouldn't cause\n    //     the build to fail.\n    console.log(filename + ': warn: ' + msg);\n  };\n\n  var mergedCssAst = CssTools.mergeCssAsts(cssAsts, warnCb);\n\n  // Overwrite the CSS files list with the new concatenated file\n  var stringifiedCss = CssTools.stringifyCss(mergedCssAst, {\n    sourcemap: true,\n    // don't try to read the referenced sourcemaps from the input\n    inputSourcemaps: false\n  });\n\n  if (! stringifiedCss.code) {\n    return { code: '' };\n  }\n\n  // Add the contents of the input files to the source map of the new file\n  stringifiedCss.map.sourcesContent =\n    stringifiedCss.map.sources.map(function (filename) {\n      return originals[filename].getContentsAsString();\n    });\n\n  var newMap;\n\n  Profile.time(\"composing source maps\", function () {\n    // If any input files had source maps, apply them.\n    // Ex.: less -> css source map should be composed with css -> css source map\n    newMap = sourcemap.SourceMapGenerator.fromSourceMap(\n      new sourcemap.SourceMapConsumer(stringifiedCss.map));\n\n    Object.keys(originals).forEach(function (name) {\n      var file = originals[name];\n      if (! file.getSourceMap())\n        return;\n      try {\n        newMap.applySourceMap(\n          new sourcemap.SourceMapConsumer(file.getSourceMap()), name);\n      } catch (err) {\n        // If we can't apply the source map, silently drop it.\n        //\n        // XXX This is here because there are some less files that\n        // produce source maps that throw when consumed. We should\n        // figure out exactly why and fix it, but this will do for now.\n      }\n    });\n  });\n\n  return {\n    code: stringifiedCss.code,\n    sourceMap: newMap.toString()\n  };\n});\n"]}