{"version":3,"sources":["meteor://ðŸ’»app/packages/minifier-css/minification.js","meteor://ðŸ’»app/packages/minifier-css/minifier.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/packages/minifier-css.js","sourcesContent":["// http://stackoverflow.com/questions/9906794/internet-explorers-css-rules-limits\nvar LIMIT = 4095;\n\n// Stringifier based on css-stringify\nvar emit = function (str) {\n  return str.toString();\n};\n\nvar visit = function (node, last) {\n  return traverse[node.type](node, last);\n};\n\nvar mapVisit = function (nodes) {\n  var buf = \"\";\n\n  for (var i = 0, length = nodes.length; i < length; i++) {\n    buf += visit(nodes[i], i === length - 1);\n  }\n\n  return buf;\n};\n\n// returns a list of strings\nMinifyAst = function(node) {\n  // the approach is taken from BlessCSS\n\n  var newAsts = [];\n  var current = {\n    selectors: 0,\n    nodes: []\n  };\n\n  var startNewAst = function () {\n    newAsts.push({\n      type: 'stylesheet',\n      stylesheet: {\n        rules: current.nodes\n      }\n    });\n\n    current.nodes = [];\n    current.selectors = 0;\n  };\n\n  _.each(node.stylesheet.rules, function (rule) {\n    switch (rule.type) {\n      case 'rule':\n        if (current.selectors + rule.selectors.length > LIMIT) {\n          startNewAst();\n        }\n\n        current.selectors += rule.selectors.length;\n        current.nodes.push(rule);\n        break;\n      case 'comment':\n        // no-op\n        break;\n      default:\n        // nested rules\n        var nested = 0;\n        _.each(rule.rules, function (nestedRule) {\n          if (nestedRule.selectors) {\n            nested += nestedRule.selectors.length;\n          }\n        });\n\n        if (current.selectors + nested > LIMIT) {\n          startNewAst();\n        }\n\n        current.selectors += nested;\n        current.nodes.push(rule);\n        break;\n    }\n  });\n\n  // push the left-over\n  if (current.nodes.length > 0) {\n    startNewAst();\n  }\n\n  var stringifyAst = function (node) {\n    return node.stylesheet\n      .rules.map(function (rule) { return visit(rule); })\n      .join('');\n  };\n\n  return newAsts.map(stringifyAst);\n};\n\nvar traverse = {};\n\ntraverse.comment = function(node) {\n  return emit('', node.position);\n};\n\ntraverse.import = function(node) {\n  return emit('@import ' + node.import + ';', node.position);\n};\n\ntraverse.media = function(node) {\n  return emit('@media ' + node.media, node.position, true)\n    + emit('{')\n    + mapVisit(node.rules)\n    + emit('}');\n};\n\ntraverse.document = function(node) {\n  var doc = '@' + (node.vendor || '') + 'document ' + node.document;\n\n  return emit(doc, node.position, true)\n    + emit('{')\n    + mapVisit(node.rules)\n    + emit('}');\n};\n\ntraverse.charset = function(node) {\n  return emit('@charset ' + node.charset + ';', node.position);\n};\n\ntraverse.namespace = function(node) {\n  return emit('@namespace ' + node.namespace + ';', node.position);\n};\n\ntraverse.supports = function(node){\n  return emit('@supports ' + node.supports, node.position, true)\n    + emit('{')\n    + mapVisit(node.rules)\n    + emit('}');\n};\n\ntraverse.keyframes = function(node) {\n  return emit('@'\n    + (node.vendor || '')\n    + 'keyframes '\n    + node.name, node.position, true)\n    + emit('{')\n    + mapVisit(node.keyframes)\n    + emit('}');\n};\n\ntraverse.keyframe = function(node) {\n  var decls = node.declarations;\n\n  return emit(node.values.join(','), node.position, true)\n    + emit('{')\n    + mapVisit(decls)\n    + emit('}');\n};\n\ntraverse.page = function(node) {\n  var sel = node.selectors.length\n    ? node.selectors.join(', ')\n    : '';\n\n  return emit('@page ' + sel, node.position, true)\n    + emit('{')\n    + mapVisit(node.declarations)\n    + emit('}');\n};\n\ntraverse['font-face'] = function(node){\n  return emit('@font-face', node.position, true)\n    + emit('{')\n    + mapVisit(node.declarations)\n    + emit('}');\n};\n\ntraverse.rule = function(node) {\n  var decls = node.declarations;\n  if (!decls.length) return '';\n\n  var selectors = node.selectors.map(function (selector) {\n    // removes universal selectors like *.class => .class\n    // removes optional whitespace around '>' and '+'\n    return selector.replace(/\\*\\./, '.')\n                   .replace(/\\s*>\\s*/g, '>')\n                   .replace(/\\s*\\+\\s*/g, '+');\n  });\n  return emit(selectors.join(','), node.position, true)\n    + emit('{')\n    + mapVisit(decls)\n    + emit('}');\n};\n\ntraverse.declaration = function(node, last) {\n  var value = node.value;\n\n  // remove optional quotes around font name\n  if (node.property === 'font') {\n    value = value.replace(/\\'[^\\']+\\'/g, function (m) {\n      if (m.indexOf(' ') !== -1)\n        return m;\n      return m.replace(/\\'/g, '');\n    });\n    value = value.replace(/\\\"[^\\\"]+\\\"/g, function (m) {\n      if (m.indexOf(' ') !== -1)\n        return m;\n      return m.replace(/\\\"/g, '');\n    });\n  }\n  // remove url quotes if possible\n  // in case it is the last declaration, we can omit the semicolon\n  return emit(node.property + ':' + value, node.position)\n         + (last ? '' : emit(';'));\n};\n","var cssParse = Npm.require('css-parse');\nvar cssStringify = Npm.require('css-stringify');\nvar url = Npm.require('url');\nvar path = Npm.require('path');\n\nCssTools = {\n  parseCss: cssParse,\n  stringifyCss: cssStringify,\n  minifyCss: function (cssText) {\n    return CssTools.minifyCssAst(cssParse(cssText));\n  },\n  minifyCssAst: function (cssAst) {\n    return MinifyAst(cssAst);\n  },\n  mergeCssAsts: function (cssAsts, warnCb) {\n    var rulesPredicate = function (rules) {\n      if (! _.isArray(rules))\n        rules = [rules];\n      return function (node) {\n        return _.contains(rules, node.type);\n      }\n    };\n\n    // Simple concatenation of CSS files would break @import rules\n    // located in the beginning of a file. Before concatenation, pull them to\n    // the beginning of a new syntax tree so they always precede other rules.\n    var newAst = {\n      type: 'stylesheet',\n      stylesheet: { rules: [] }\n    };\n\n    _.each(cssAsts, function (ast) {\n      // Pick only the imports from the beginning of file ignoring @charset\n      // rules as every file is assumed to be in UTF-8.\n      var charsetRules = _.filter(ast.stylesheet.rules,\n                                  rulesPredicate(\"charset\"));\n\n      if (_.any(charsetRules, function (rule) {\n        // According to MDN, only 'UTF-8' and \"UTF-8\" are the correct encoding\n        // directives representing UTF-8.\n        return ! /^(['\"])UTF-8\\1$/.test(rule.charset);\n      })) {\n        warnCb(ast.filename, \"@charset rules in this file will be ignored as UTF-8 is the only encoding supported\");\n      }\n\n      ast.stylesheet.rules = _.reject(ast.stylesheet.rules,\n                                      rulesPredicate(\"charset\"));\n      var importCount = 0;\n      for (var i = 0; i < ast.stylesheet.rules.length; i++)\n        if (! rulesPredicate([\"import\", \"comment\"])(ast.stylesheet.rules[i])) {\n          importCount = i;\n          break;\n        }\n\n      CssTools.rewriteCssUrls(ast);\n\n      var imports = ast.stylesheet.rules.splice(0, importCount);\n      newAst.stylesheet.rules = newAst.stylesheet.rules.concat(imports);\n\n      // if there are imports left in the middle of file, warn user as it might\n      // be a potential bug (imports are valid only in the beginning of file).\n      if (_.any(ast.stylesheet.rules, rulesPredicate(\"import\"))) {\n        // XXX make this an error?\n        warnCb(ast.filename, \"there are some @import rules those are not taking effect as they are required to be in the beginning of the file\");\n      }\n\n    });\n\n    // Now we can put the rest of CSS rules into new AST\n    _.each(cssAsts, function (ast) {\n      newAst.stylesheet.rules =\n        newAst.stylesheet.rules.concat(ast.stylesheet.rules);\n    });\n\n    return newAst;\n  },\n\n  // We are looking for all relative urls defined with the `url()` functional\n  // notation and rewriting them to the equivalent absolute url using the\n  // `position.source` path provided by css-parse\n  // For performance reasons this function acts by side effect by modifying the\n  // given AST without doing a deep copy.\n  rewriteCssUrls: function (ast) {\n    rewriteRules(ast.stylesheet.rules);\n  }\n};\n\nif (typeof Profile !== 'undefined') {\n  _.each(['parseCss', 'stringifyCss', 'minifyCss',\n          'minifyCssAst', 'mergeCssAsts', 'rewriteCssUrls'],\n         function (funcName) {\n           CssTools[funcName] = Profile('CssTools.'+funcName,\n                                        CssTools[funcName]);\n         });\n}\n\nvar rewriteRules = function (rules) {\n  _.each(rules, function(rule, ruleIndex) {\n\n    // Recurse if there are sub-rules. An example:\n    //     @media (...) {\n    //         .rule { url(...); }\n    //     }\n    if (_.has(rule, 'rules')) {\n      rewriteRules(rule.rules);\n    }\n\n    var basePath = pathDirname(rule.position.source);\n\n    // Set the correct basePath based on how the linked asset will be served.\n    // XXX This is wrong. We are coupling the information about how files will\n    // be served by the web server to the information how they were stored\n    // originally on the filesystem in the project structure. Ideally, there\n    // should be some module that tells us precisely how each asset will be\n    // served but for now we are just assuming that everything that comes from\n    // a folder starting with \"/packages/\" is served on the same path as\n    // it was on the filesystem and everything else is served on root \"/\".\n    if (! basePath.match(/^\\/?packages\\//i))\n        basePath = \"/\";\n\n    _.each(rule.declarations, function(declaration, declarationIndex) {\n      var parts, resource, absolutePath, quotes, oldCssUrl, newCssUrl;\n      var value = declaration.value;\n\n      // Match css values containing some functional calls to `url(URI)` where\n      // URI is optionally quoted.\n      // Note that a css value can contains other elements, for instance:\n      //   background: top center url(\"background.png\") black;\n      // or even multiple url(), for instance for multiple backgrounds.\n      var cssUrlRegex = /url\\s*\\(\\s*(['\"]?)(.+?)\\1\\s*\\)/gi;\n      while (parts = cssUrlRegex.exec(value)) {\n        oldCssUrl = parts[0];\n        quotes = parts[1];\n        resource = url.parse(parts[2]);\n\n        // Rewrite relative paths to absolute paths.\n        // We don't rewrite urls starting with a protocol definition such as\n        // http, https, or data.\n        if (isRelative(resource.path) && resource.protocol === null) {\n          absolutePath = pathJoin(basePath, resource.path);\n          newCssUrl = \"url(\" + quotes + absolutePath + quotes + \")\";\n          value = value.replace(oldCssUrl, newCssUrl);\n        }\n      }\n\n      declaration.value = value;\n    });\n  });\n};\n\nvar isRelative = function(path) {\n  return path && path.charAt(0) !== '/';\n};\n\n// These are duplicates of functions in tools/files.js, because we don't have\n// a good way of exporting them into packages.\n// XXX deduplicate files.js into a package at somepoint so that we can use it\n// in core\nvar toOSPath = function (p) {\n  if (process.platform === 'win32')\n    return p.replace(/\\//g, '\\\\');\n  return p;\n}\n\nvar toStandardPath = function (p) {\n  if (process.platform === 'win32')\n    return p.replace(/\\\\/g, '/');\n  return p;\n};\n\nvar pathJoin = function (a, b) {\n  return toStandardPath(path.join(\n    toOSPath(a),\n    toOSPath(b)));\n};\n\nvar pathDirname = function (p) {\n  return toStandardPath(path.dirname(toOSPath(p)));\n};\n"]}